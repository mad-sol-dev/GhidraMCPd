![ghidra_MCP_logo](images/ghidraMCPd.png)

# Ghidra MCPd - token-efficient MCP server for Ghidra

Deterministic MCP server for the Ghidra plugin focused on lowering token spend while keeping schemas stable and auditable.

> **âš ï¸ AI-Generated Code:** This repository's code is almost entirely generated by AI assistants (Codex, AiderDesk). Human role: architecture, planning, review, testing, and documentation. Use at your own risk.
>
> **Status:** Experimental â€¢ **License:** Apache 2.0  
> **Credit:** Fork of **GhidraMCP** - thanks to **Laurie Wired** for the original project.

## Motivation

Started as a side-quest while building an e-recumbent bike battery (needed to label matched cells â†’ bought a Chinease handheld HP45 printer â†’ found SD card â†’ firmware RE â†’ here we are ðŸš´).

Bridging Ghidra through MCP can be API-expensive when clients emit many small calls. Ghidra MCPd reduces this through:
- **Batch operations**: `disassemble_batch`, `read_words` - analyze multiple addresses in one call
- **Server-side context**: `search_scalars_with_context` - includes surrounding disassembly
- **Efficient pagination**: Resume cursors and deterministic limits

Token savings depend on workflow, but batching operations significantly reduces round-trips and response overhead.

## Highlights

* Batch ops: `disassemble_batch`, `read_words`
* Context search: `search_scalars_with_context` (server-side windowing)
* Deterministic envelopes & schemas (`{ok,data,errors[]}`, `additionalProperties:false`)
* Guard rails: write-guards (`ENABLE_WRITES`, `dry_run`), safety limits, observability via `/state`
* Tested: contract, golden (OpenAPI/HTTP parity), unit

## Quickstart

```bash
python -m venv .venv
source .venv/bin/activate
python -m pip install -r requirements.txt -r requirements-dev.txt
uvicorn bridge.app:create_app --factory --host 127.0.0.1 --port 8000
```

Once running, open Ghidra with a project and the server will connect automatically.

## Example Usage

```bash
# Find all functions using MMIO address 0x40000000
curl -X POST http://localhost:8000/api/search_scalars_with_context.json \
  -H 'content-type: application/json' \
  -d '{"value":"0x40000000","context_lines":2,"limit":10}'

# Analyze function with decompiler
curl -X POST http://localhost:8000/api/analyze_function_complete.json \
  -H 'content-type: application/json' \
  -d '{"address":"0x1000","fields":["function","decompile","xrefs"]}'
```

## Build the Ghidra extension

Populate `lib/` with the required Ghidra jars, then run Maven:

```bash
python scripts/fetch_ghidra_jars.py
mvn -DskipTests package
```

If you already have a local Ghidra checkout, you can still point Maven at it directly:

```bash
export GHIDRA_DIR=/path/to/ghidra_*_PUBLIC && mvn -DskipTests package
```

The build produces `target/GhidraMCP-1.0-SNAPSHOT.jar`.

**Installation:**

1. Copy the JAR to Ghidra's Extensions directory:
   ```bash
   cp target/GhidraMCP-1.0-SNAPSHOT.jar $GHIDRA_INSTALL_DIR/Extensions/Ghidra/
   ```

2. Or use Ghidra's GUI: **File â†’ Install Extensions** and select the JAR file.

3. Restart Ghidra to load the extension.

## Advanced start

Run the server and verify deterministic behavior:

```bash
curl -sS http://localhost:8000/openapi.json | jq '.info.title'
# â†’ 200 JSON ("Ghidra MCP Bridge API")

curl -iN http://localhost:8000/sse
# keep this stream open (HTTP/1.1 200)

curl -i http://localhost:8000/sse
# â†’ HTTP/1.1 409 Conflict (single active SSE)

curl -i -X POST http://localhost:8000/sse
# â†’ HTTP/1.1 405 Method Not Allowed + {"allow":"GET"}

curl -i http://localhost:8000/messages
# before readiness â†’ HTTP/1.1 425 Too Early + {"error":"mcp_not_ready"}

curl -sS -X POST http://localhost:8000/api/write_bytes.json \
  -H 'content-type: application/json' \
  -d '{"address":"0x00400000","data":"AAEC","dry_run":true}'
# â†’ {"ok":true,"data":{"written":false,...,"notes":["dry-run enabled: no bytes written", ...]},"errors":[]}
```

## API Overview

### Search & Analysis
* `/api/search_strings.json` - Search for strings with pagination
* `/api/search_functions.json` - Find functions by name pattern
* `/api/search_scalars.json` - Locate scalar values in code
* `/api/search_scalars_with_context.json` - Scalars with surrounding disassembly
* `/api/search_imports.json` / `/api/search_exports.json` - Symbol search
* `/api/search_xrefs_to.json` - Cross-references to an address

### Memory & Disassembly
* `/api/read_bytes.json` - Read raw bytes from memory
* `/api/read_words.json` - Batch read 32-bit words
* `/api/disassemble_at.json` - Disassemble at address
* `/api/disassemble_batch.json` - Batch disassembly of multiple addresses

### Advanced Analysis
* `/api/analyze_function_complete.json` - Complete function analysis (decompile, xrefs, etc.)
* `/api/list_functions_in_range.json` - List functions in address range
* `/api/mmio_annotate.json` - Annotate MMIO accesses
* `/api/jt_scan.json` / `/api/jt_slot_check.json` / `/api/jt_slot_process.json` - Jump table analysis

### Data & Utilities
* `/api/strings_compact.json` - Bulk string listing
* `/api/string_xrefs.json` - Cross-references to strings
* `/api/write_bytes.json` - Write bytes (requires `ENABLE_WRITES`)
* `/api/project_info.json` - Project metadata
* `/api/health.json` - Server health check

See the complete reference in [docs/api.md](docs/api.md).

## Documentation

* [Getting started](docs/getting-started.md) - Installation and configuration
* [Server operations](docs/server.md) - Running and managing the server
* [Troubleshooting](docs/troubleshooting.md) - Common issues and solutions
* [Development workflow](docs/development.md) - Contributing and `.plan/` process

## Status

This repo is maintained with a deterministic plan. See [Development](docs/development.md) for the `.plan/` workflow.

## Contributing

Contributions welcome! This is an experimental project with AI-generated code - review carefully and test thoroughly. See [Development workflow](docs/development.md) for the `.plan/` process.

## License

Apache 2.0 - See [LICENSE](LICENSE) for details.
